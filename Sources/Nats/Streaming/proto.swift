// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/proto3.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2016-2018 The NATS Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Uses https://github.com/gogo/protobuf
// compiled via `protoc -I=. -I=$GOPATH/src  --gogofaster_out=. protocol.proto`

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enum for start position type.
public enum Pb_StartPosition: SwiftProtobuf.Enum {
    public typealias RawValue = Int
  case newOnly // = 0
  case lastReceived // = 1
  case timeDeltaStart // = 2
  case sequenceStart // = 3
  case first // = 4
  case UNRECOGNIZED(Int)

public init() {
    self = .newOnly
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .newOnly
    case 1: self = .lastReceived
    case 2: self = .timeDeltaStart
    case 3: self = .sequenceStart
    case 4: self = .first
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

    public var rawValue: Int {
    switch self {
    case .newOnly: return 0
    case .lastReceived: return 1
    case .timeDeltaStart: return 2
    case .sequenceStart: return 3
    case .first: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Pb_StartPosition: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Pb_StartPosition] = [
    .newOnly,
    .lastReceived,
    .timeDeltaStart,
    .sequenceStart,
    .first,
  ]
}

#endif  // swift(>=4.2)

/// How messages are delivered to the STAN cluster
public struct Pb_PubMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClientID
  var clientID: String = String()

  /// guid
  var guid: String = String()

  /// subject
  var subject: String = String()

  /// optional reply
  var reply: String = String()

  /// payload
  var data: Data = SwiftProtobuf.Internal.emptyData

  /// Connection ID. For servers that know about this field, clientID can be omitted
  var connID: Data = SwiftProtobuf.Internal.emptyData

  /// optional sha256 of data
  var sha256: Data = SwiftProtobuf.Internal.emptyData

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Used to ACK to publishers
public struct Pb_PubAck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// guid
  var guid: String = String()

  /// err string, empty/omitted if no error
  var error: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Msg struct. Sequence is assigned for global ordering by
/// the cluster after the publisher has been acknowledged.
public struct Pb_MsgProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// globally ordered sequence number for the subject's channel
  public var sequence: UInt64 = 0

  /// subject
  public var subject: String = String()

  /// optional reply
  public var reply: String = String()

  /// payload
  public var data: Data = SwiftProtobuf.Internal.emptyData

  /// received timestamp
  public var timestamp: Int64 = 0

  /// Flag specifying if the message is being redelivered
  public var redelivered: Bool = false

  /// optional IEEE CRC32
  public var crc32: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Ack will deliver an ack for a delivered msg.
public struct Pb_Ack {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Subject
  var subject: String = String()

  /// Sequence to acknowledge
  var sequence: UInt64 = 0

    var dummy: String = String()
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Connection Request
struct Pb_ConnectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Client name/identifier.
  var clientID: String = String()

  /// Inbox for server initiated heartbeats.
  var heartbeatInbox: String = String()

  /// Protocol the client is at.
  var `protocol`: Int32 = 0

  /// Connection ID, a way to uniquely identify a connection (no connection should ever have the same)
  var connID: Data = SwiftProtobuf.Internal.emptyData

  /// Interval at which client wishes to send PINGs (expressed in seconds).
  var pingInterval: Int32 = 0

  /// Maximum number of PINGs without a response after which the connection can be considered lost.
  var pingMaxOut: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response to a client connect
public struct Pb_ConnectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Prefix to use when publishing to this STAN cluster
  var pubPrefix: String = String()

  /// Subject to use for subscription requests
  var subRequests: String = String()

  /// Subject to use for unsubscribe requests
  var unsubRequests: String = String()

  /// Subject for closing the stan connection
  var closeRequests: String = String()

  /// err string, empty/omitted if no error
  var error: String = String()

  /// Subject to use for subscription close requests
  var subCloseRequests: String = String()

  /// Subject to use for PING requests
  var pingRequests: String = String()

  /// Interval at which client should send PINGs (expressed in seconds).
  var pingInterval: Int32 = 0

  /// Maximum number of PINGs without a response after which the connection can be considered lost
  var pingMaxOut: Int32 = 0

  /// Protocol version the server is at
  var `protocol`: Int32 = 0

  /// Possibly used to sign acks, etc.
  var publicKey: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// PING from client to server
struct Pb_Ping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Connection ID
  var connID: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PING response from the server
struct Pb_PingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Error string, empty/omitted if no error
  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Protocol for a client to subscribe
struct Pb_SubscriptionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClientID
  var clientID: String = String()

  /// Formal subject to subscribe to, e.g. foo.bar
  var subject: String = String()

  /// Optional queue group
  var qGroup: String = String()

  /// Inbox subject to deliver messages on
  var inbox: String = String()

  /// Maximum inflight messages without an ack allowed
  var maxInFlight: Int32 = 0

  /// Timeout for receiving an ack from the client
  var ackWaitInSecs: Int32 = 0

  /// Optional durable name which survives client restarts
  var durableName: String = String()

  /// Start position
  var startPosition: Pb_StartPosition = .newOnly

  /// Optional start sequence number
  var startSequence: UInt64 = 0

  /// Optional start time
  var startTimeDelta: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for SubscriptionRequest and UnsubscribeRequests
struct Pb_SubscriptionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ackInbox for sending acks
  var ackInbox: String = String()

  /// err string, empty/omitted if no error
  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Protocol for a clients to unsubscribe. Will return a SubscriptionResponse
struct Pb_UnsubscribeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClientID
  var clientID: String = String()

  /// subject for the subscription
  var subject: String = String()

  /// Inbox subject to identify subscription
  var inbox: String = String()

  /// Optional durable name which survives client restarts
  var durableName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Protocol for a client to close a connection
struct Pb_CloseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Client name provided to Connect() requests
  var clientID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for CloseRequest
struct Pb_CloseResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// err string, empty/omitted if no error
  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pb"

extension Pb_StartPosition: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NewOnly"),
    1: .same(proto: "LastReceived"),
    2: .same(proto: "TimeDeltaStart"),
    3: .same(proto: "SequenceStart"),
    4: .same(proto: "First"),
  ]
}

extension Pb_PubMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".PubMsg"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clientID"),
    2: .same(proto: "guid"),
    3: .same(proto: "subject"),
    4: .same(proto: "reply"),
    5: .same(proto: "data"),
    6: .same(proto: "connID"),
    10: .same(proto: "sha256"),
  ]

    mutating public func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.clientID)
      case 2: try decoder.decodeSingularStringField(value: &self.guid)
      case 3: try decoder.decodeSingularStringField(value: &self.subject)
      case 4: try decoder.decodeSingularStringField(value: &self.reply)
      case 5: try decoder.decodeSingularBytesField(value: &self.data)
      case 6: try decoder.decodeSingularBytesField(value: &self.connID)
      case 10: try decoder.decodeSingularBytesField(value: &self.sha256)
      default: break
      }
    }
  }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if !self.guid.isEmpty {
      try visitor.visitSingularStringField(value: self.guid, fieldNumber: 2)
    }
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 3)
    }
    if !self.reply.isEmpty {
      try visitor.visitSingularStringField(value: self.reply, fieldNumber: 4)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 5)
    }
    if !self.connID.isEmpty {
      try visitor.visitSingularBytesField(value: self.connID, fieldNumber: 6)
    }
    if !self.sha256.isEmpty {
      try visitor.visitSingularBytesField(value: self.sha256, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

    public static func ==(lhs: Pb_PubMsg, rhs: Pb_PubMsg) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.guid != rhs.guid {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs.reply != rhs.reply {return false}
    if lhs.data != rhs.data {return false}
    if lhs.connID != rhs.connID {return false}
    if lhs.sha256 != rhs.sha256 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_PubAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".PubAck"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "guid"),
    2: .same(proto: "error"),
  ]

    mutating public func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.guid)
      case 2: try decoder.decodeSingularStringField(value: &self.error)
      default: break
      }
    }
  }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.guid.isEmpty {
      try visitor.visitSingularStringField(value: self.guid, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

    public static func ==(lhs: Pb_PubAck, rhs: Pb_PubAck) -> Bool {
    if lhs.guid != rhs.guid {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_MsgProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".MsgProto"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sequence"),
    2: .same(proto: "subject"),
    3: .same(proto: "reply"),
    4: .same(proto: "data"),
    5: .same(proto: "timestamp"),
    6: .same(proto: "redelivered"),
    10: .same(proto: "CRC32"),
  ]

    mutating public func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.sequence)
      case 2: try decoder.decodeSingularStringField(value: &self.subject)
      case 3: try decoder.decodeSingularStringField(value: &self.reply)
      case 4: try decoder.decodeSingularBytesField(value: &self.data)
      case 5: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 6: try decoder.decodeSingularBoolField(value: &self.redelivered)
      case 10: try decoder.decodeSingularUInt32Field(value: &self.crc32)
      default: break
      }
    }
  }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequence, fieldNumber: 1)
    }
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 2)
    }
    if !self.reply.isEmpty {
      try visitor.visitSingularStringField(value: self.reply, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 5)
    }
    if self.redelivered != false {
      try visitor.visitSingularBoolField(value: self.redelivered, fieldNumber: 6)
    }
    if self.crc32 != 0 {
      try visitor.visitSingularUInt32Field(value: self.crc32, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

    public static func ==(lhs: Pb_MsgProto, rhs: Pb_MsgProto) -> Bool {
    if lhs.sequence != rhs.sequence {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs.reply != rhs.reply {return false}
    if lhs.data != rhs.data {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.redelivered != rhs.redelivered {return false}
    if lhs.crc32 != rhs.crc32 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Ack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Ack"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subject"),
    2: .same(proto: "sequence"),
    3: .same(proto: "dummy"),
  ]

    mutating public func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.subject)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.sequence)
      default: break
      }
    }
  }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 1)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequence, fieldNumber: 2)
    }
        if !self.dummy.isEmpty {
            try visitor.visitSingularStringField(value: self.dummy, fieldNumber: 3)
        }
    try unknownFields.traverse(visitor: &visitor)
  }

    public static func ==(lhs: Pb_Ack, rhs: Pb_Ack) -> Bool {
    if lhs.subject != rhs.subject {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clientID"),
    2: .same(proto: "heartbeatInbox"),
    3: .same(proto: "protocol"),
    4: .same(proto: "connID"),
    5: .same(proto: "pingInterval"),
    6: .same(proto: "pingMaxOut"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.clientID)
      case 2: try decoder.decodeSingularStringField(value: &self.heartbeatInbox)
      case 3: try decoder.decodeSingularInt32Field(value: &self.`protocol`)
      case 4: try decoder.decodeSingularBytesField(value: &self.connID)
      case 5: try decoder.decodeSingularInt32Field(value: &self.pingInterval)
      case 6: try decoder.decodeSingularInt32Field(value: &self.pingMaxOut)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if !self.heartbeatInbox.isEmpty {
      try visitor.visitSingularStringField(value: self.heartbeatInbox, fieldNumber: 2)
    }
    if self.`protocol` != 0 {
      try visitor.visitSingularInt32Field(value: self.`protocol`, fieldNumber: 3)
    }
    if !self.connID.isEmpty {
      try visitor.visitSingularBytesField(value: self.connID, fieldNumber: 4)
    }
    if self.pingInterval != 0 {
      try visitor.visitSingularInt32Field(value: self.pingInterval, fieldNumber: 5)
    }
    if self.pingMaxOut != 0 {
      try visitor.visitSingularInt32Field(value: self.pingMaxOut, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_ConnectRequest, rhs: Pb_ConnectRequest) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.heartbeatInbox != rhs.heartbeatInbox {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.connID != rhs.connID {return false}
    if lhs.pingInterval != rhs.pingInterval {return false}
    if lhs.pingMaxOut != rhs.pingMaxOut {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static public let protoMessageName: String = _protobuf_package + ".ConnectResponse"
  static public let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubPrefix"),
    2: .same(proto: "subRequests"),
    3: .same(proto: "unsubRequests"),
    4: .same(proto: "closeRequests"),
    5: .same(proto: "error"),
    6: .same(proto: "subCloseRequests"),
    7: .same(proto: "pingRequests"),
    8: .same(proto: "pingInterval"),
    9: .same(proto: "pingMaxOut"),
    10: .same(proto: "protocol"),
    100: .same(proto: "publicKey"),
  ]

    mutating public func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pubPrefix)
      case 2: try decoder.decodeSingularStringField(value: &self.subRequests)
      case 3: try decoder.decodeSingularStringField(value: &self.unsubRequests)
      case 4: try decoder.decodeSingularStringField(value: &self.closeRequests)
      case 5: try decoder.decodeSingularStringField(value: &self.error)
      case 6: try decoder.decodeSingularStringField(value: &self.subCloseRequests)
      case 7: try decoder.decodeSingularStringField(value: &self.pingRequests)
      case 8: try decoder.decodeSingularInt32Field(value: &self.pingInterval)
      case 9: try decoder.decodeSingularInt32Field(value: &self.pingMaxOut)
      case 10: try decoder.decodeSingularInt32Field(value: &self.`protocol`)
      case 100: try decoder.decodeSingularStringField(value: &self.publicKey)
      default: break
      }
    }
  }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.pubPrefix, fieldNumber: 1)
    }
    if !self.subRequests.isEmpty {
      try visitor.visitSingularStringField(value: self.subRequests, fieldNumber: 2)
    }
    if !self.unsubRequests.isEmpty {
      try visitor.visitSingularStringField(value: self.unsubRequests, fieldNumber: 3)
    }
    if !self.closeRequests.isEmpty {
      try visitor.visitSingularStringField(value: self.closeRequests, fieldNumber: 4)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 5)
    }
    if !self.subCloseRequests.isEmpty {
      try visitor.visitSingularStringField(value: self.subCloseRequests, fieldNumber: 6)
    }
    if !self.pingRequests.isEmpty {
      try visitor.visitSingularStringField(value: self.pingRequests, fieldNumber: 7)
    }
    if self.pingInterval != 0 {
      try visitor.visitSingularInt32Field(value: self.pingInterval, fieldNumber: 8)
    }
    if self.pingMaxOut != 0 {
      try visitor.visitSingularInt32Field(value: self.pingMaxOut, fieldNumber: 9)
    }
    if self.`protocol` != 0 {
      try visitor.visitSingularInt32Field(value: self.`protocol`, fieldNumber: 10)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

    public static func ==(lhs: Pb_ConnectResponse, rhs: Pb_ConnectResponse) -> Bool {
    if lhs.pubPrefix != rhs.pubPrefix {return false}
    if lhs.subRequests != rhs.subRequests {return false}
    if lhs.unsubRequests != rhs.unsubRequests {return false}
    if lhs.closeRequests != rhs.closeRequests {return false}
    if lhs.error != rhs.error {return false}
    if lhs.subCloseRequests != rhs.subCloseRequests {return false}
    if lhs.pingRequests != rhs.pingRequests {return false}
    if lhs.pingInterval != rhs.pingInterval {return false}
    if lhs.pingMaxOut != rhs.pingMaxOut {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Ping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Ping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.connID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connID.isEmpty {
      try visitor.visitSingularBytesField(value: self.connID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_Ping, rhs: Pb_Ping) -> Bool {
    if lhs.connID != rhs.connID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_PingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.error)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_PingResponse, rhs: Pb_PingResponse) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SubscriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscriptionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clientID"),
    2: .same(proto: "subject"),
    3: .same(proto: "qGroup"),
    4: .same(proto: "inbox"),
    5: .same(proto: "maxInFlight"),
    6: .same(proto: "ackWaitInSecs"),
    7: .same(proto: "durableName"),
    10: .same(proto: "startPosition"),
    11: .same(proto: "startSequence"),
    12: .same(proto: "startTimeDelta"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.clientID)
      case 2: try decoder.decodeSingularStringField(value: &self.subject)
      case 3: try decoder.decodeSingularStringField(value: &self.qGroup)
      case 4: try decoder.decodeSingularStringField(value: &self.inbox)
      case 5: try decoder.decodeSingularInt32Field(value: &self.maxInFlight)
      case 6: try decoder.decodeSingularInt32Field(value: &self.ackWaitInSecs)
      case 7: try decoder.decodeSingularStringField(value: &self.durableName)
      case 10: try decoder.decodeSingularEnumField(value: &self.startPosition)
      case 11: try decoder.decodeSingularUInt64Field(value: &self.startSequence)
      case 12: try decoder.decodeSingularInt64Field(value: &self.startTimeDelta)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 2)
    }
    if !self.qGroup.isEmpty {
      try visitor.visitSingularStringField(value: self.qGroup, fieldNumber: 3)
    }
    if !self.inbox.isEmpty {
      try visitor.visitSingularStringField(value: self.inbox, fieldNumber: 4)
    }
    if self.maxInFlight != 0 {
      try visitor.visitSingularInt32Field(value: self.maxInFlight, fieldNumber: 5)
    }
    if self.ackWaitInSecs != 0 {
      try visitor.visitSingularInt32Field(value: self.ackWaitInSecs, fieldNumber: 6)
    }
    if !self.durableName.isEmpty {
      try visitor.visitSingularStringField(value: self.durableName, fieldNumber: 7)
    }
    if self.startPosition != .newOnly {
      try visitor.visitSingularEnumField(value: self.startPosition, fieldNumber: 10)
    }
    if self.startSequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.startSequence, fieldNumber: 11)
    }
    if self.startTimeDelta != 0 {
      try visitor.visitSingularInt64Field(value: self.startTimeDelta, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SubscriptionRequest, rhs: Pb_SubscriptionRequest) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs.qGroup != rhs.qGroup {return false}
    if lhs.inbox != rhs.inbox {return false}
    if lhs.maxInFlight != rhs.maxInFlight {return false}
    if lhs.ackWaitInSecs != rhs.ackWaitInSecs {return false}
    if lhs.durableName != rhs.durableName {return false}
    if lhs.startPosition != rhs.startPosition {return false}
    if lhs.startSequence != rhs.startSequence {return false}
    if lhs.startTimeDelta != rhs.startTimeDelta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SubscriptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscriptionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "ackInbox"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularStringField(value: &self.ackInbox)
      case 3: try decoder.decodeSingularStringField(value: &self.error)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ackInbox.isEmpty {
      try visitor.visitSingularStringField(value: self.ackInbox, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SubscriptionResponse, rhs: Pb_SubscriptionResponse) -> Bool {
    if lhs.ackInbox != rhs.ackInbox {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_UnsubscribeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnsubscribeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clientID"),
    2: .same(proto: "subject"),
    3: .same(proto: "inbox"),
    4: .same(proto: "durableName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.clientID)
      case 2: try decoder.decodeSingularStringField(value: &self.subject)
      case 3: try decoder.decodeSingularStringField(value: &self.inbox)
      case 4: try decoder.decodeSingularStringField(value: &self.durableName)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 2)
    }
    if !self.inbox.isEmpty {
      try visitor.visitSingularStringField(value: self.inbox, fieldNumber: 3)
    }
    if !self.durableName.isEmpty {
      try visitor.visitSingularStringField(value: self.durableName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_UnsubscribeRequest, rhs: Pb_UnsubscribeRequest) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs.inbox != rhs.inbox {return false}
    if lhs.durableName != rhs.durableName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_CloseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clientID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.clientID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_CloseRequest, rhs: Pb_CloseRequest) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_CloseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.error)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_CloseResponse, rhs: Pb_CloseResponse) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
